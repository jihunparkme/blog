# Making Method Calls Simpler

## [Rename Method](https://sourcemaking.com/refactoring/rename-method)

**메서드의 이름이 메서드의 목적과 의도를 드러내지 않을 경우**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/rename-method.png?raw=true 'Result')

- 복잡한 프로세스를 작은 메서드로 분리하는 것은 좋은 코딩 스타일 `Composed Method`
- 메서드에 어떤 커멘트가 적절한지 생각하고 이를 메소드 이름으로 변경하는게 좋은 방법

## [Add Parameter](https://sourcemaking.com/refactoring/add-parameter)

**메서드가 호출자에게 보다 많은 정보를 필요로 하는 경우**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/add-parameter.png?raw=true 'Result')

**Before**

```java
```

**After**

```java
```

- 필요한 정보를 전달할 수 있는 객체를 파라미터로 추가
- `Introduct Parameter` or `Change Signature` in IntelliJ
- 파라미터의 개수가 많아지면 `Introduce Parameter Object` 고려하기

## [Remove Parameter](https://sourcemaking.com/refactoring/remove-parameter)

**파라미터가 메서드에서 더 이상 사용되지 않을 경우**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/remove-parameter.png?raw=true 'Result')

- 지금 사용하지 않은 것은 바로바로 지우자

## [Separate Query from Modifier](https://sourcemaking.com/refactoring/separate-query-from-modifier)

**값은 반환하지만 객체의 상태도 변경하는 메서드가 있을 경우**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/separate-query-from-modifier.png?raw=true 'Result')

- CQS(Command Query Separation)를 위반할 경우, CQS를 준수하도록 분리
  - 쿼리와 변경을 위한 두 개의 메서드로 생성
- CQS를 위반한 경우 리펙터링도 어려워짐
- side effect 가 있는 메서드와 없는 메서드를 분리

## [Parameterized Method](https://sourcemaking.com/refactoring/parameterize-method)

**몇 개의 메서드가 유사한 일을 하지만 메서드 바디가 다른 경우**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/parameterize-method.png?raw=true 'Result')

**Before**

```java
@Test
void parameterizedMethod() {
    class Employee {
        private double salary;

        void tenPercentRaise() {
            salary *= 1.1;
        }

        void fivePercentRaise() {
            salary *= 1.05;
        }
    }

    final Employee e = new Employee();
    e.tenPercentRaise();
    e.fivePercentRaise();
}
```

**After**

```java
@Test
void parameterizedMethod() {
    class Employee {
        private double salary;

        void raise(double factor) {
            salary *= factor;
        }

    }

    final Employee e = new Employee();
    e.raise(1.1);
    e.raise(1.05);
}
```

- 서로 다른 값을 위해 파라미터를 갖는 하나의 메서드를 생성

## [Replace Parameter With Explicit Methods](https://sourcemaking.com/refactoring/replace-parameter-with-explicit-methods)

**열거된 파라미터(enumerated parameter)에 따라 다른 코드를 실행하는 메서드가 있는 경우**

### Example01

**Before**

```java
void setValue(String name, int value) {
  if (name.equals("height")) {
    height = value;
    return;
  }
  if (name.equals("width")) {
    width = value;
    return;
  }
  Assert.shouldNeverReachHere();
}
```

**After**

```java
void setHeight(int arg) {
  height = arg;
}
void setWidth(int arg) {
  width = arg;
}
```

### Example02

**Bbefore**

```java
static class Employee {
    static Employee create(int type) {
        switch (type) {
            case ENGINEER:
                return new Engineer();
            case SALESMAN:
                return new Salesman();
            case MANAGER:
                return new Manager();
            default:
                throw new IllegalArgumentException("Incorrect type code value");
        }
    }

    private static class Engineer extends Employee {
    }

    private static class Salesman extends Employee {
    }

    private static class Manager extends Employee {
    }
}
```

**After**

```java
static class Employee {
    static Employee createEngineer() {
        return new Engineer();
    }

    static Employee createSalesman() {
        return new Salesman();
    }

    static Employee createManager() {
        return new Manager();
    }

    private static class Engineer extends Employee {
    }

    private static class Salesman extends Employee {
    }

    private static class Manager extends Employee {
    }
}

@Test
void replaceParameterWithExplicitMethods() {
    Employee kent = Employee.createEngineer();
    Employee beck = Employee.createSalesman();
    Employee bob = Employee.createManager();
}
```

- `Parameterized Method`의 반대
- 파라미터의 각 값에 대해 별도의 메서드를 생성
- 파라미터의 값이 많이 변경되는 경우는 부적합

## [Preserve Whole Object](https://sourcemaking.com/refactoring/preserve-whole-object)

**파라미터로 객체의 여러개의 값을 전달할 경우**

**Before**

```java
int low = daysTempRange.getLow();
int high = daysTempRange.getHigh();
boolean withinPlan = plan.withinRange(low, high);
```

**After**

```java
boolean withinPlan = plan.withinRange(daysTempRange);
```

- 파라미터대신 객체를 전달
- 필요하지 않은 데이터까지 전달되어 결합도가 증가하는 문제가 발생할 수 있음

.

- 호출되는 메소드에서 다른 객체가 가지고 있는 값을 많이 사용한다면 `Move Method`
- 만일 원하는 값을 가진 객체가 존재하지 않는다면 `Introduce Parameter Object`
- 일반적인 경우, 호출 객체가 자체 데이터 값을 매개 변수로 전달
  - 호출 객체에 대한 의존성이 문제가 되지 않는다면, 값들을 전달하는 대신 적절한 getter가 있는 this 전달 가능

## [Replace Parameter with Method](https://sourcemaking.com/refactoring/replace-parameter-with-method-call)

**Before**

```java
int basePrice = quantity * itemPrice;
double seasonDiscount = this.getSeasonalDiscount();
double fees = this.getFees();
double finalPrice = discountedPrice(basePrice, seasonDiscount, fees);
```

**After**

```java
int basePrice = quantity * itemPrice;
double finalPrice = discountedPrice(basePrice);
```

## [Introduce Paramter Object](https://sourcemaking.com/refactoring/introduce-parameter-object)

**Before**

```java
```

**After**

```java
```

## [Remove Setting Method](https://sourcemaking.com/refactoring/remove-setting-method)

**Before**

```java
```

**After**

```java
```

## [Hide Method](https://sourcemaking.com/refactoring/hide-method)

**Before**

```java
```

**After**

```java
```

## [Replace Constructor with Factory Method](https://sourcemaking.com/refactoring/replace-constructor-with-factory-method)

**Before**

```java
class Employee {
  Employee(int type) {
    this.type = type;
  }
  // ...
}
```

**After**

```java
class Employee {
  static Employee create(int type) {
    employee = new Employee(type);
    // do some heavy lifting.
    return employee;
  }
  // ...
}
```

## Encapsulate Downcast

**Before**

```java
```

**After**

```java
```

## [Replace Error Code With Exception](https://sourcemaking.com/refactoring/replace-error-code-with-exception)

**Before**

```java
int withdraw(int amount) {
  if (amount > _balance) {
    return -1;
  }
  else {
    balance -= amount;
    return 0;
  }
}
```

**After**

```java
void withdraw(int amount) throws BalanceException {
  if (amount > _balance) {
    throw new BalanceException();
  }
  balance -= amount;
}
```

## [Replace Exception With Test](https://sourcemaking.com/refactoring/replace-exception-with-test)

**Before**

```java
double getValueForPeriod(int periodNumber) {
  try {
    return values[periodNumber];
  } catch (ArrayIndexOutOfBoundsException e) {
    return 0;
  }
}
```

**After**

```java
double getValueForPeriod(int periodNumber) {
  if (periodNumber >= values.length) {
    return 0;
  }
  return values[periodNumber];
}
```
