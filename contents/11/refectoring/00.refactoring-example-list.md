# Refectoring Example List

## [Composing Methods](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#composing-methods)

- [Extract Method](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#extract-method)
- [Inline Method](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#inline-method)
- [Inline Temp](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#inline-temp)
- [Replace Temp With Query](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#replace-temp-with-query)
- [Introduce Explaining Variable](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#introduce-explaining-variable)
- [Split Temporary Variable](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#split-temporary-variable)
- [Remove Assignments to Parameters](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#remove-assignments-to-parameters)
- [Replace Method with Method Object](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#replace-method-with-method-object)
- [Substitute Algorithm](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/06.Composing-Methods.md#substitute-algorithm)

## [Moving Features Between Objects](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#moving-features-between-objects)

- [Move Method](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#move-method)
  - 다른 클래스의 기능을 사용하거나 다른 클래스에 의해 사용되는 메서드 이동
- [Move Field](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#move-field)
  - 어떤 필드가 자신이 정의된 클래스보다 다른 클래스에 의해 더 많이 사용될 경우
- [Extract Class](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#extract-class)
  - 두 개 이상의 클래스가 수행해야 할 일을 하나의 클래스가 수행할 경우
- [INLINE CLASS](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#inline-class)
  - 특정 클래스가 하는 일이 없을 때
- [Hide Delegate](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#hide-delegate)
  - 클라이언트가 대리(delegatee) 클래스의 객체를 호출할 경우
- [Remove Middleman](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#remove-middleman)
  - 클래스가 너무 단순한 위임만 하는 경우
- [Introduce Foreign Method](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#introduce-foreign-method)
  - 사용 중인 서버 클래스에 메소드를 추가해야 하지만, 클래스 수정이 불가능할 경우
- [Introduce Local Extension](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/07.Moving-Features-Between-Objects.md#introduce-local-extension)
  - 특정 클래스에 기능을 추가해야 하는데, 해당 클래스를 수정할 수 없을 경우

## [Organizing Data](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#organizing-data)

- [Self Encapsulate Field](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#self-encapsulate-field)
  - 서브클래스에서 오버라이드할 경우
- [Replace Data Value with Object](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-data-value-with-object)
  - 추가적인 데이터나 행위를 필요로하는 데이터 아이템이 있는 경우 객체로 전환
- [Change Value to Reference](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#change-value-to-reference)
  - 동일한 인스트턴스를 하나의 객체로 치환하고자 할 경우 객체를 참조 객체로 전환
- [Change Reference to Value](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#change-reference-to-value)
  - 관리하기 어려운 작은 불변 참조 객체가 있을 경우 값 객체로 변환
- [Replace Array with Object](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-array-with-object)
  - 서로 다른 원소를 의미하는 배열이 존재하는 경우, 배열의 각 요소에 대한 필드가 있는 객체로 변경
- [Duplicate Observed Data](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#duplicate-observed-data)
  - UI 객체가 자신이 수행하지 말아야 할 비즈니스 로직을 수행하는 경우
- [Change Unidirectional Association to Bidirectional](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#change-unidirectional-association-to-bidirectional)
  - 두 클래스의 단방향 링크를 양방향으로 변경할 경우
- [Change Bidirectional Association to Unidirectional](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#change-bidirectional-association-to-unidirectional)
  - 클래스가 양방향 관계를 가지고 있지만 하나의 클래스에서 더 이상 참조가 필요하지 않을 경우
- [Replace Magic Number with Symbolic Constant](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-magic-number-with-symbolic-constant)
  - 특별한 의미를 갖는 리터럴 넘버를 의미에 맞는 이름의 상수로 치환
- [Encapsulate Field](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#encapsulate-field)
  - public 필드가 존재할 경우
- [Encapsulate Collection](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#encapsulate-collection)
  - 특정 메서드가 컬렉션을 반환할 경우
- [Replace Type Code with Class](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-type-code-with-class)
  - 행위에 영향을 미치지 않는 숫자 타입 코드를 갖는 클래스가 존재할 경우
- [Replace Type Code with Subclasses](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-type-code-with-subclasses)
  - 클래스 행위에 영향을 미치는 불변 타입 코드가 있을 경우 서브 클래스로 변환
- [Replace Type Code with State/Strategy](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-type-code-with-statestrategy)
  - Replace Type Code with Subclasses 와 유사하지만, 타입 코드가 변경되거나, 서브클래싱을 할 수 없을 경우
- [Replace Subclass With Fields](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/08.Organizing-Data.md#replace-subclass-with-fields)
  - 상수를 반환하는 단순한 메소드가 다른 서브 클래스에 있을 경우

## [Simplifying Conditional Expressions](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#simplifying-conditional-expressions)

- [Decompose Conditional](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#decompose-conditional)
  - 복잡한 조건문이 존재하는 경우
- [Consolidate Conditional Expression](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#consolidate-conditional-expression)
  - 동일한 then 파트를 갖는 일련의 조건문이 존재하는 경우
- [Consolidate Duplicate Conditional Fragments](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#consolidate-duplicate-conditional-fragments)
  - 동일 코드들이 조건문의 여러 분기문에 존재할 경우
- [Remove Control Flag](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#remove-control-flag)
  - 일련의 boolean 표현식에 대해 제어 플래그로 동작하는 변수가 있을 경우
- [Replace Nested Conditional With Guard Clauses](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#replace-nested-conditional-with-guard-clauses)
  - 메소드가 명확한 정상 실행 경로를 만들지 못하는 조건 행위를 갖는 경우
- [Replace Conditional With Polymorphism](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#replace-conditional-with-polymorphism)
  - 객체의 타입에 따라 다른 행위를 갖는 조건문이 존재할 경우
- [Introduce Null Object](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#introduce-null-object)
  - 널 값 조사를 반복적으로 하는 경우
- [Introduce Assertion](https://github.com/jihunparkme/blog/blob/main/contents/11/refectoring/09.Simplifying-Conditional-Expressions.md#introduce-assertion)
  - 코드 섹션이 프로그램의 상태에 대해 어떤 가정을 하는 경우