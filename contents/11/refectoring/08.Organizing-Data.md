# Organizing Data

## [Self Encapsulate Field](https://sourcemaking.com/refactoring/self-encapsulate-field)

**Self Encapsulate Field를 사용하는 가장 중요한 시기는 서브클래스에서 오버라이드할 경우**

**before**

```java
class Range {
  private int low, high;

  boolean includes(int arg) {
    return arg >= low && arg <= high;
  }
}
```

**After**

```java
class Range {
  private int low, high;

  boolean includes(int arg) {
    return arg >= getLow() && arg <= getHigh();
  }
  int getLow() {
    return low;
  }
  int getHigh() {
    return high;
  }
}
```

- 초기엔 멤버 변수를 직접 사용하고 필요 시 `Self Encapsulate Field` 적용
- 필드를 private으로 변경 -> 필드에 대한 접근자(getter/setter) 생성

## [Replace Data Value with Object](https://sourcemaking.com/refactoring/replace-data-value-with-object)

**추가적인 데이터나 행위를 필요로하는 데이터 아이템이 있는 경우 객체로 전환**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/replace-data-value-with-object.png?raw=true 'Result')

**before**

```java
class Order {
  private String customer;

  public Order (String customer) {
    customer = customer;
  }

  public String getCustomer() {
    return customer;
  }
}
```

**After**

```java
class Order {
  private final Customer customer;

  public Order (Customer customer) {
    customer = customer;
  }

  public String getCustomer() {
    return customer.getName();
  }
}

class Customer {
  private final String name;

  public Customer (String name) {
    this.name = name;
  }

  public String getName() {
    return name;    
  }
}
```

- 종종 간단한 데이터 값으로 시작하고 후에 객체가 더 유용하다는 것을 인식
- `Replace Data Value with Object`는 기능이 없는 데이터를 명료한 객체로 변경
- 이러한 객체들이 프로그램의 여러 곳에서 요구된다면 `Change Value to Reference`를 적용하여 참조 객체로 만들어보자

