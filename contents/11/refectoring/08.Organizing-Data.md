# Organizing Data

## [Self Encapsulate Field](https://sourcemaking.com/refactoring/self-encapsulate-field)

**Self Encapsulate Field를 사용하는 가장 중요한 시기는 서브클래스에서 오버라이드할 경우**

**before**

```java
class Range {
  private int low, high;

  boolean includes(int arg) {
    return arg >= low && arg <= high;
  }
}
```

**After**

```java
class Range {
  private int low, high;

  boolean includes(int arg) {
    return arg >= getLow() && arg <= getHigh();
  }
  int getLow() {
    return low;
  }
  int getHigh() {
    return high;
  }
}
```

- 초기엔 멤버 변수를 직접 사용하고 필요 시 `Self Encapsulate Field` 적용
- 필드를 private으로 변경 -> 필드에 대한 접근자(getter/setter) 생성

## [Replace Data Value with Object](https://sourcemaking.com/refactoring/replace-data-value-with-object)

**추가적인 데이터나 행위를 필요로하는 데이터 아이템이 있는 경우 객체로 전환**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/replace-data-value-with-object.png?raw=true 'Result')

**before**

```java
class Order {
  private String customer;

  public Order (String customer) {
    customer = customer;
  }

  public String getCustomer() {
    return customer;
  }
}
```

**After**

```java
class Order {
  private final Customer customer;

  public Order (Customer customer) {
    customer = customer;
  }

  public String getCustomer() {
    return customer.getName();
  }
}

class Customer {
  private final String name;

  public Customer (String name) {
    this.name = name;
  }

  public String getName() {
    return name;    
  }
}
```

- 종종 간단한 데이터 값으로 시작하고 후에 객체가 더 유용하다는 것을 인식
- `Replace Data Value with Object`는 기능이 없는 데이터를 명료한 객체로 변경
- 이러한 객체들이 프로그램의 여러 곳에서 요구된다면 `Change Value to Reference`를 적용하여 참조 객체로 만들어보자

## [Change Value to Reference](https://sourcemaking.com/refactoring/change-value-to-reference)

**동일한 인스트턴스를 하나의 객체로 치환하고자 할 경우 객체를 참조 객체로 전환**

![Result](https://github.com/jihunparkme/blog/blob/main/img/11-seminar/refactoring/change-value-to-reference.png?raw=true 'Result')

**before**

```java
class Customer {
  private final String name;

  public Customer(String name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }
}

class Order {
  private Customer customer;

  // 각각의 주문은 자신만의 고객 객체를 갖는 값 객체
  public Order(String customerName) {
    customer = new Customer(customerName);
  }

  public void setCustomer(String customerName) {
    customer = new Customer(customerName);
  }

  public String getCustomerName() {
    return customer.getName();
  }
}

private static int numberOfOrdersFor(List<Order> orders, String customer) {
  int result = 0;
  for (Order each : orders) {
    if (each.getCustomerName().equals(customer))
      result++;
  }
  return result;
}
```

**After**

```java
class Customer {
  private final String name;

  private Customer(String name) {
    this.name = name;
  }

  public static Customer create(String name) {
    return new Customer(name);
  }

  public String getName() {
    return name;
  }
}

class Order {
  private Customer customer;

  // 여러개의 주문이 동일한 고객 객체를 공유하도록 변경
  private Order(String customerName) {
    customer = Customer.create(customerName);
  }

  public void setCustomer(String customerName) {
    customer = Customer.create(customerName);
  }

  public String getCustomerName() {
    return customer.getName();
  }
}

private static int numberOfOrdersFor(List<Order> orders, String customer) {
  int result = 0;
  for (Order each : orders) {
    if (each.getCustomerName().equals(customer))
      result++;
  }
  return result;
}
```

- `Replace Constructor with Factory Method` 적용
- 어떤 객체가 참조 객체에 대한 책임을 갖는지 결정
- 객체가 미리 생성되어야 하는지 요청이 있을 때 생성되어야 하는지 결정
- 팩토리 메소드가 참조 객체를 반환하도록 변경

.

- 참조 객체(Reference Object)
    - 고객, 계좌와 같이 실세계에서 하나의 객체
    - 동일성 비교는 객체 ID(object identity) 사용
- 값 객체(Value Object)
    - 날짜, 화폐와 같은 데이터 값
    - 동일성 비교를 위해 equals(hashCode) 재정의 필요
- 참조 객체인지 값 객체인지 구분하는 것은 불명확할 수 있음
    - 적은 불변 데이터를 갖는 단순한 객체로 시작
    - 점차 변경 가능한 데이터를 제공하고 변경이 객체를 참조하는 모든 클라이언트에 파급되도록 수정
    - 이 시점에서는 참조 객체로 변경 필요

