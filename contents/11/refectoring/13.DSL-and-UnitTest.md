# DSL-and-UnitTest

## 응집도와 결합도

응집도와 결합도
- 결합도: 서로 다른 모듈 간에 상호 의존하는 정도 또는 연관된 관계
 - 낮은 결합도를 가진 클래스는 변경과 재사용이 유용
- 응집도: 한 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도
 - 하나의 기능 중심으로 책임이 잘 뭉쳐있는 높은 응집도를 가진 모듈이 좋음

## 단위 테스트의 늪

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = new Planet(new
                Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(
                            new Continent("아시아"),
                            new Continent("유럽")),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))));
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}
```

**애매한 테스트(OBSCURE TEST)**

- 픽스처와 무관한 정보를 너무 상세하게 노출 (중요한 로직 파악 어려움)
- 생성자에 전달된 인자 중 테스트에서 검증하려는 대륙의 수와 관련이 있는 것은 Continent 뿐
- 테스트하려는 행위와 무관한 정보는 테스트의 목적을 흐리고, 가독성을 저하

**깨지기 쉬운 테스트(FRAGILE TEST)**

- 생성자의 시그니처가 변경될 경우 객체들을 사용하는 모든 테스트 케이스를 수정해야 함
  - 인터페이스에 민감함(Interface Sensitivity) 문제
  - 생성자를 여러 테스트 케이스에서 호출한다면 문제가 더 커짐

## 테스트 코드 리팩토링

### 생성 메서드

**Creation Method**

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = createPlanet();
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}

private Planet createPlanet() {
    return new Planet(
                new Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(
                            new Continent("아시아"),
                            new Continent("유럽")),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))))
}
```

- 테스트와 관련 없는 정보를 너무 상세하게 노출시켜 애매한 테스트가 되는 문제를 해결
- 픽스처 생성 코드를 메서드로 추출하여 별도의 Test Utility Method로 분리
- 단, 테스트와 관련된 중요한 정보를 은폐하는 문제 발생

### 매개 변수화된 생성 메소드

**Parameterized Creation Method**

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = createPlanet(
                new Continent("아시아"),
                new Continent("유럽"));
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}

private Planet createPlanet(Continent... continents) {
    return new Planet(
                new Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(continents),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))))
}
```

- 테스트와 무관한 정보는 기본값을 설정하도록 생성 메서드 내에 캡슐화
- 테스트와 관련된 정보만 파라미터로 전달하여 테스트 검증에 중요한 정보를 명시화

### 슈퍼 클래스를 이용한 생성 메서드의 중복 제거

**TESTCASE SUPERCLASS**

- 생성 메서드가 특정한 테스트 케이스 클래스와 강하게 결합된 경우, 다른 테스트 케이스 클래스에서 재사용 하기 위한 해결책
- 두 테스트 케이스 클래스의 생성 메서드를 공통 부모 클래스로 이동 (`EXTRACT SUPER CLASS`, `PULL UP METHOD`)
- 단, 단일 상속 제약의 존재와 다양한 픽스처 생성을 위한 수많은 생성 메서드를 가진 슈퍼 클래스는 관리와 유지보수에 어려움이 있음

### FACTORY를 이용한 생성 메서드 중복 제거

**CREATION METHOD using Test Helper**

- Test Helper
  - 테스트 케이스 클래스 간의 중복 코드를 제거하기 위해 재사용 가능한 테스트 유틸리티 메서드를 제공하는 독립적인 클래스
  - 테스트에 필요한 픽스처의 생성, 수정, 삭제와 관련된 책임을 담당
- 슈퍼 클래스가 아닌 별도의 독립 클래스(Test Helper)로 생성 메서드(CREATION METHOD)를 옮겨 위임 적용
  - 슈퍼 클래스는 분리된 별도 클래스를 호출하고 테스트 코드에서는 Test Helper의 static method 호출로 픽스처 생성
- 하지만, 이 방법도 시스템의 규모가 증가할수록 유지보수의 한계에 봉착

**ONE BAD ATTRIBUTE Pattern**

- 생성 메서드의 증가에 따른 코드 중복을 해결하는 방법
- 하지만, 결국 이 방법도 단점이 존재
  - 불변 객체 생성 불가
  - 캡슐화 저해
  - 속성 조합으로 인한 생성 메서드의 폭발적 증가
  - 속성 추가/삭제 시 클래스 인터페이스 변경으로 인한 파급 효과
- 대안으로  TEST DATA BUILDER Pattern 존재

## Reference

> [DSL and UnitTest 1_2](https://github.com/jihunparkme/lecture-material/blob/master/seminar/Ch13.DSL-and-UnitTest-1_2.pdf)
> 
> [DSL and UnitTest 2_2](https://github.com/jihunparkme/lecture-material/blob/master/seminar/Ch13.DSL-and-UnitTest-2_2.pdf)