# DSL-and-UnitTest

## 응집도와 결합도

응집도와 결합도
- 결합도: 서로 다른 모듈 간에 상호 의존하는 정도 또는 연관된 관계
 - 낮은 결합도를 가진 클래스는 변경과 재사용이 유용
- 응집도: 한 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도
 - 하나의 기능 중심으로 책임이 잘 뭉쳐있는 높은 응집도를 가진 모듈이 좋음

## 단위 테스트의 늪

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = new Planet(new
                Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(
                            new Continent("아시아"),
                            new Continent("유럽")),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))));
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}
```

**애매한 테스트(OBSCURE TEST)**

- 픽스처와 무관한 정보를 너무 상세하게 노출 (중요한 로직 파악 어려움)
- 생성자에 전달된 인자 중 테스트에서 검증하려는 대륙의 수와 관련이 있는 것은 Continent 뿐
- 테스트하려는 행위와 무관한 정보는 테스트의 목적을 흐리고, 가독성을 저하

**깨지기 쉬운 테스트(FRAGILE TEST)**

- 생성자의 시그니처가 변경될 경우 객체들을 사용하는 모든 테스트 케이스를 수정해야 함
  - 인터페이스에 민감함(Interface Sensitivity) 문제
  - 생성자를 여러 테스트 케이스에서 호출한다면 문제가 더 커짐

## 테스트 코드 리팩토링

### 생성 메서드

**Creation Method**

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = createPlanet();
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}

private Planet createPlanet() {
    return new Planet(
                new Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(
                            new Continent("아시아"),
                            new Continent("유럽")),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))))
}
```

- 테스트와 관련 없는 정보를 너무 상세하게 노출시켜 애매한 테스트가 되는 문제를 해결
- 픽스처 생성 코드를 메서드로 추출하여 별도의 Test Utility Method로 분리
- 단, 테스트와 관련된 중요한 정보를 은폐하는 문제 발생

### 매개 변수화된 생성 메소드

**Parameterized Creation Method**

```java
class ContinentSpecificationShould {
    @Test
    public void specified_with_a_planet() {
        Planet planet = createPlanet(
                new Continent("아시아"),
                new Continent("유럽"));
        
        ContinentSpecification specification = new ContinentSpecification(2);
        
        assertTrue(specification.test(planet));
    }
}

private Planet createPlanet(Continent... continents) {
    return new Planet(
                new Atmosphere(Money.wons(5000),
                            element("N", Ratio.of(0.8)),
                            element("O", Ratio.of(0.2))), 
                Arrays.asList(continents),
                Arrays.asList(
                            new Ocean("태평양",Money.wons(1000)),
                            new Ocean("대서양", Money.wons(1000))))
}
```

- 테스트와 무관한 정보는 기본값을 설정하도록 생성 메서드 내에 캡슐화
- 테스트와 관련된 정보만 파라미터로 전달하여 테스트 검증에 중요한 정보를 명시화

### 슈퍼 클래스를 이용한 생성 메서드의 중복 제거

**TESTCASE SUPERCLASS**

- 생성 메서드가 특정한 테스트 케이스 클래스와 강하게 결합된 경우, 다른 테스트 케이스 클래스에서 재사용 하기 위한 해결책
- 두 테스트 케이스 클래스의 생성 메서드를 공통 부모 클래스로 이동 (`EXTRACT SUPER CLASS`, `PULL UP METHOD`)
- 단, 단일 상속 제약의 존재와 다양한 픽스처 생성을 위한 수많은 생성 메서드를 가진 슈퍼 클래스는 관리와 유지보수에 어려움이 있음

### FACTORY를 이용한 생성 메서드 중복 제거

**CREATION METHOD using Test Helper**

- Test Helper
  - 테스트 케이스 클래스 간의 중복 코드를 제거하기 위해 재사용 가능한 테스트 유틸리티 메서드를 제공하는 독립적인 클래스
  - 테스트에 필요한 픽스처의 생성, 수정, 삭제와 관련된 책임을 담당
- 슈퍼 클래스가 아닌 별도의 독립 클래스(Test Helper)로 생성 메서드(CREATION METHOD)를 옮겨 위임 적용
  - 슈퍼 클래스는 분리된 별도 클래스를 호출하고 테스트 코드에서는 Test Helper의 static method 호출로 픽스처 생성
- 하지만, 이 방법도 시스템의 규모가 증가할수록 유지보수의 한계에 봉착

**ONE BAD ATTRIBUTE Pattern**

- 생성 메서드의 증가에 따른 코드 중복을 해결하는 방법
- 하지만, 결국 이 방법도 단점이 존재
  - 불변 객체 생성 불가
  - 캡슐화 저해
  - 속성 조합으로 인한 생성 메서드의 폭발적 증가
  - 속성 추가/삭제 시 클래스 인터페이스 변경으로 인한 파급 효과
- 대안으로  TEST DATA BUILDER Pattern 존재

---

## 도메인 특화 언어

**DSL, Domain-Specific Language**

- SW 본질적인 문제인 복잡도를 해결할 수 있을 것으로 기대되는 한 가지 설계 방식
- 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어

### 도메인 특화 언어의 구조

#### **CQS**

- 인터페이스 설계 원칙 중 하나
- 메서드는 반드시 부수 효과를 발생시키는 `커맨드이거나` 부수 효과를 발생시키지 않는 `쿼리` 둘 중 하나여야하고, 두 가지 특성 모두를 가져서는 안 된다.
- 사용 문맥과의 결합도를 최소화하도록 설계

#### **DSL**

- 유창한 인터페이스(Fluent Interface)
  - CQS와 대조적으로 사용되는 문맥에 기반한 유창함을 강조
- CQS는 문맥과 무관하게 독립적으로 사용될 것을 가정하고, 이름 안에 최대한 많은 정보를 담으려고 노력
- DSL은 특정한 사용 문맥을 가정하고, 연결되는 문맥 상에서 충분한 의미를 가질 수 있는 간결한 이름을 사용하려고 노력
- 커맨드-쿼리 인터페이스는 훌륭한 객체 인터페이스, 유창한 인터페이스는 훌륭한 DSL 인터페이스를 낳는다

DSL을 구조화하는 일반적인 방식은 커맨드-쿼리 인터페이스를 제공하는 객체 모델 위에 유창한 인터페이스 방식의 독립적인 DSL 레이어를 구축하는 것이다.

- 커맨드-쿼리 인터페이스를 제공하는 하부 모델 위에서 유창한 인터페이스를 제공하는 독립적인 언어 계층을 표현식 빌더(EXPRESSION BUILDER)라고 함
- DSL은 커맨드-쿼리 인터페이스 기반의 객체 모델을 제어할 수 있는 유창한 인터페이스를 제공하는 일종의 FAÇADE(건물의 출입구로 이용되는 정면 외벽 부분)

### Context Variable

### 내부 DSL(Internal DSL)

**메서드 체이닝(METHOD CHAINING)**
**함수 시퀀스(FUNCTION SEQUENCE)**
**내포 함수(NESTED FUNCTION)**
**객체 범위(OBJECT SCOPING)**

## 테스트 도메인에 특화된 언어

**OBJECT MOTHER 패턴**
**TEST DATA BUILDER 패턴**

## 테스트 케이스 리팩토링

## Reference

> [DSL and UnitTest 1_2](https://github.com/jihunparkme/lecture-material/blob/master/seminar/Ch13.DSL-and-UnitTest-1_2.pdf)
> 
> [DSL and UnitTest 2_2](https://github.com/jihunparkme/lecture-material/blob/master/seminar/Ch13.DSL-and-UnitTest-2_2.pdf)